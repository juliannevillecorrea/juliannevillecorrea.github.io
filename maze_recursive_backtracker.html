<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Printable Maze — Recursive Backtracker (DFS)</title>
  <style>
    :root{--bg:#fff;--fg:#111;--accent:#0b74de}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--fg)}
    .wrap{max-width:1100px;margin:18px auto;padding:18px}
    header{display:flex;gap:12px;align-items:center}
    h1{margin:0;font-size:18px}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin:12px 0}
    label{font-size:13px}
    input[type=number], select{padding:6px;border-radius:6px;border:1px solid #ddd}
    button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    #canvasWrap{border:1px solid #ddd;padding:10px;display:inline-block;background:#fff}
    canvas{display:block}
    .actions{display:flex;gap:8px;align-items:center;margin-top:10px}
    .hint{font-size:13px;color:#555;margin-top:8px}

    /* Print-friendly: hide controls and ensure canvas fills page */
    @media print{
      body{margin:0}
      .controls, .actions, header{display:none}
      #canvasWrap{border:none;padding:0}
      canvas{width:100vw;height:100vh;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Maze generator — Recursive Backtracker (depth-first) — printable</h1>
    </header>

    <div class="controls">
      <label>Columns: <input id="cols" type="number" min="4" max="300" value="40"></label>
      <label>Rows: <input id="rows" type="number" min="4" max="300" value="40"></label>
      <label>Cell size (px): <input id="cellSize" type="number" min="4" max="80" value="18"></label>
      <label>Line width: <input id="lineWidth" type="number" min="1" max="6" value="2"></label>
      <label>Seed (optional): <input id="seed" placeholder="leave empty for random"></label>
      <label>Show solution: <select id="showSolution"><option value="no">No</option><option value="yes">Yes</option></select></label>
      <button id="generate">Generate</button>
    </div>

    <div id="canvasWrap">
      <canvas id="mazeCanvas"></canvas>
    </div>

    <div class="actions">
      <button id="downloadPng">Download PNG</button>
      <button id="downloadSvg">Download SVG</button>
      <button id="printBtn">Print (open print dialog)</button>
      <div class="hint">Tip: press the Download SVG button to get a crisp, printable vector file. Use Print for direct printing.</div>
    </div>

    <p class="hint">Algorithm: Recursive Backtracker (iterative stack). This page is a single-file generator you can host as-is on your website.</p>
  </div>

<script>
// Simple seeded RNG (mulberry32) — optional reproducible mazes when seed provided
function mulberry32(a){return function(){a |= 0; a = a + 0x6D2B79F5 | 0; var t = Math.imul(a ^ a >>> 15, 1 | a); t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t; return ((t ^ t >>> 14) >>> 0) / 4294967296;}}

// Maze generator using iterative Recursive Backtracker
function generateMaze(cols, rows, rng){
  const total = cols*rows;
  // walls: each cell has walls N,E,S,W as booleans
  const cells = new Array(total).fill(0).map(()=>({visited:false,walls:[true,true,true,true]}));
  const stack = [];
  const index = (x,y)=> x + y*cols;
  const neighbors = (x,y)=>{
    const n = [];
    if(y>0) n.push([x,y-1,0]); // N
    if(x<cols-1) n.push([x+1,y,1]); // E
    if(y<rows-1) n.push([x,y+1,2]); // S
    if(x>0) n.push([x-1,y,3]); // W
    return n;
  }

  const startX = Math.floor(rng()*cols);
  const startY = Math.floor(rng()*rows);
  let cur = [startX,startY];
  cells[index(startX,startY)].visited = true;
  let visitedCount = 1;

  while(visitedCount < total){
    const x = cur[0], y = cur[1];
    const neigh = neighbors(x,y).filter(n=>!cells[index(n[0],n[1])].visited);
    if(neigh.length){
      const pick = neigh[Math.floor(rng()*neigh.length)];
      const nx = pick[0], ny = pick[1], dir = pick[2];
      // remove wall between cur and pick
      const curCell = cells[index(x,y)];
      const nextCell = cells[index(nx,ny)];
      curCell.walls[dir] = false;
      nextCell.walls[(dir+2)%4] = false;
      stack.push(cur);
      cur = [nx,ny];
      nextCell.visited = true;
      visitedCount++;
    } else if(stack.length){
      cur = stack.pop();
    } else {
      // pick random unvisited cell to continue (rare)
      for(let i=0;i<cells.length;i++){
        if(!cells[i].visited){
          const sx = i % cols; const sy = Math.floor(i/cols);
          cur = [sx,sy]; cells[i].visited = true; visitedCount++; break;
        }
      }
    }
  }
  return {cols,rows,cells};
}

function drawMazeToCanvas(m, cellSize, lineWidth, showSolution){
  const canvas = document.getElementById('mazeCanvas');
  const pad = 8;
  const w = m.cols*cellSize + pad*2;
  const h = m.rows*cellSize + pad*2;
  canvas.width = Math.ceil(w);
  canvas.height = Math.ceil(h);
  canvas.style.width = canvas.width + 'px';
  canvas.style.height = canvas.height + 'px';
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.lineWidth = lineWidth; ctx.lineCap='square'; ctx.strokeStyle = '#000';

  const getXY = (i)=>{
    const x = (i % m.cols);
    const y = Math.floor(i / m.cols);
    return [pad + x*cellSize, pad + y*cellSize];
  }

  ctx.beginPath();
  for(let i=0;i<m.cells.length;i++){
    const [x,y] = getXY(i);
    const w = m.cells[i].walls;
    if(w[0]){ ctx.moveTo(x,y); ctx.lineTo(x+cellSize,y);} // N
    if(w[1]){ ctx.moveTo(x+cellSize,y); ctx.lineTo(x+cellSize,y+cellSize);} // E
    if(w[2]){ ctx.moveTo(x+cellSize,y+cellSize); ctx.lineTo(x,y+cellSize);} // S
    if(w[3]){ ctx.moveTo(x,y+cellSize); ctx.lineTo(x,y);} // W
  }
  ctx.stroke();

  if(showSolution){
    const path = solveMaze(m, 0, m.cols*m.rows-1);
    if(path){
      ctx.beginPath();
      const [sx,sy] = getXY(path[0]); ctx.moveTo(sx + cellSize/2, sy + cellSize/2);
      for(let i=1;i<path.length;i++){ const [px,py] = getXY(path[i]); ctx.lineTo(px + cellSize/2, py + cellSize/2); }
      ctx.lineWidth = Math.max(1, Math.floor(lineWidth/1.5)); ctx.strokeStyle = '#d00'; ctx.stroke();
    }
  }
}

// Simple BFS solver to get solution path from start index to end index
function solveMaze(m, startIdx, endIdx){
  const cols = m.cols, rows = m.rows; const idx = (x,y)=>x+y*cols;
  const q=[startIdx];
  const prev = new Array(cols*rows).fill(-1);
  const visited = new Array(cols*rows).fill(false);
  visited[startIdx]=true;
  while(q.length){
    const cur = q.shift();
    if(cur===endIdx) break;
    const x = cur % cols, y = Math.floor(cur/cols);
    const w = m.cells[cur].walls;
    // neighbors where no wall
    const candidates=[];
    if(!w[0] && y>0) candidates.push(idx(x,y-1));
    if(!w[1] && x<cols-1) candidates.push(idx(x+1,y));
    if(!w[2] && y<rows-1) candidates.push(idx(x,y+1));
    if(!w[3] && x>0) candidates.push(idx(x-1,y));
    for(const n of candidates){ if(!visited[n]){ visited[n]=true; prev[n]=cur; q.push(n);} }
  }
  if(!visited[endIdx]) return null;
  const path=[]; let cur=endIdx; while(cur!=-1){ path.push(cur); cur=prev[cur]; } path.reverse(); return path;
}

// Export SVG string for vector download
function mazeToSVG(m, cellSize, lineWidth, showSolution){
  const pad = 8;
  const w = m.cols*cellSize + pad*2;
  const h = m.rows*cellSize + pad*2;
  const strokeW = lineWidth;
  const lines = [];
  const getXY = (i)=>{
    const x = (i % m.cols);
    const y = Math.floor(i / m.cols);
    return [pad + x*cellSize, pad + y*cellSize];
  }
  for(let i=0;i<m.cells.length;i++){
    const [x,y] = getXY(i);
    const wall = m.cells[i].walls;
    if(wall[0]) lines.push(`<line x1="${x}" y1="${y}" x2="${x+cellSize}" y2="${y}" />`);
    if(wall[1]) lines.push(`<line x1="${x+cellSize}" y1="${y}" x2="${x+cellSize}" y2="${y+cellSize}" />`);
    if(wall[2]) lines.push(`<line x1="${x+cellSize}" y1="${y+cellSize}" x2="${x}" y2="${y+cellSize}" />`);
    if(wall[3]) lines.push(`<line x1="${x}" y1="${y+cellSize}" x2="${x}" y2="${y}" />`);
  }
  let solPath='';
  if(showSolution){
    const path = solveMaze(m, 0, m.cols*m.rows-1);
    if(path){
      const d = path.map((i,idx)=>{ const [x,y]=getXY(i); return `${idx===0?"M":"L"}${x+cellSize/2} ${y+cellSize/2}`; }).join(' ');
      solPath = `<path d="${d}" fill="none" stroke="#d00" stroke-width="${Math.max(1,strokeW/2)}" stroke-linecap="round" stroke-linejoin="round"/>`;
    }
  }

  const svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}' viewBox='0 0 ${w} ${h}'>\n  <rect width='100%' height='100%' fill='white'/>\n  <g fill='none' stroke='black' stroke-width='${strokeW}' stroke-linecap='square'>\n    ${lines.join('\n    ')}\n  </g>\n  ${solPath}\n</svg>`;
  return svg;
}

// Wiring up UI
(function(){
  const colsInp = document.getElementById('cols');
  const rowsInp = document.getElementById('rows');
  const cellSizeInp = document.getElementById('cellSize');
  const lineWidthInp = document.getElementById('lineWidth');
  const seedInp = document.getElementById('seed');
  const generateBtn = document.getElementById('generate');
  const downloadPng = document.getElementById('downloadPng');
  const downloadSvg = document.getElementById('downloadSvg');
  const printBtn = document.getElementById('printBtn');
  const showSolution = document.getElementById('showSolution');

  let lastMaze=null;

  function makeRngFromSeed(s){
    if(!s) return Math.random;
    // simple hash to 32-bit int
    let h=2166136261;
    for(let i=0;i<s.length;i++){ h = Math.imul(h ^ s.charCodeAt(i), 16777619); }
    return mulberry32(h>>>0);
  }

  function render(){
    const cols = Math.max(2, Math.min(300, parseInt(colsInp.value)||40));
    const rows = Math.max(2, Math.min(300, parseInt(rowsInp.value)||40));
    const cellSize = Math.max(4, Math.min(80, parseInt(cellSizeInp.value)||18));
    const lineWidth = Math.max(1, Math.min(8, parseInt(lineWidthInp.value)||2));
    const seed = seedInp.value.trim();
    const rng = makeRngFromSeed(seed);
    lastMaze = generateMaze(cols,rows,rng);
    drawMazeToCanvas(lastMaze,cellSize,lineWidth, showSolution.value==='yes');
  }

  generateBtn.addEventListener('click', ()=>{ render(); });
  // initial render
  render();

  downloadPng.addEventListener('click', ()=>{
    if(!lastMaze) return alert('Generate a maze first');
    const a = document.createElement('a');
    const canvas = document.getElementById('mazeCanvas');
    a.href = canvas.toDataURL('image/png');
    a.download = `maze_${lastMaze.cols}x${lastMaze.rows}.png`;
    a.click();
  });

  downloadSvg.addEventListener('click', ()=>{
    if(!lastMaze) return alert('Generate a maze first');
    const cellSize = Math.max(4, Math.min(80, parseInt(cellSizeInp.value)||18));
    const lineWidth = Math.max(1, Math.min(8, parseInt(lineWidthInp.value)||2));
    const svg = mazeToSVG(lastMaze, cellSize, lineWidth, showSolution.value==='yes');
    const blob = new Blob([svg], {type:'image/svg+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `maze_${lastMaze.cols}x${lastMaze.rows}.svg`; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  });

  printBtn.addEventListener('click', ()=>{ window.print(); });

  // handy: regenerate on Enter in seed
  seedInp.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ render(); }});

})();
</script>
</body>
</html>